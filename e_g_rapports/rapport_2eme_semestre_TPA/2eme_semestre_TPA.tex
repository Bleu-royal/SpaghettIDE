\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{url}

\begin{document}

\begin{titlepage}
	\begin{center}
		\Large{Année universitaire 2016-2017}\\
		\Large{Université de Caen Basse-Normandie}\\[1cm]
		
		\huge{Rapport du projet "IDE" de TPA}\\
		\vspace{3cm}
		
		Alexis CARREAU\\
		Thomas LÉCLUSE\\
		Emma MAUGER\\
		Théo SARRAZIN\\
		
		\normalsize{\textit{ ~ L2 Informatique}}\\
		\medskip
		\vspace{2cm}
		
		\huge{\textbf{Réalisation d'un IDE en Python}}
		
	\end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

	A la fin du premier semestre, notre IDE était capable d'ouvrir des documents avec l'extension .c ou .h à partir de projets que nous avions créé. Nous pouvions ouvrir plusieurs documents, et avoir une liste d'onglets. Nous avions un navigateur de fichiers qui nous permettait de naviguer entre nos différents projets et leurs documents. Une barre de menu nous permettait d'accéder à nos différentes fonctionnalités, et nous affichions à l'aide d'une barre de statut différents messages répondant aux requêtes de l'utilisateur.\\
	
	\includegraphics[scale=0.3]{images/ide_v1.png}
	
	Nous colorions le contenu des documents à l'aide du logiciel Lex, en particulier les différents tokens (éléments du code) selon leur fonction, et nous analysions les documents pour détecter des erreurs de syntaxe à l'aide du logiciel Yacc. Nous utilisons pour cela une grammaire.
	
	\subsection{Grammaire pour Lex et Yacc}
	
		À l'aide du module PLY (Python Lex and Yacc), nous définissons une liste de tokens afin de déterminer tous les mots clefs du langage.
		
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.6]{images/tokens}
				\caption{Exemple de liste de tokens pour les déclarations de type en C.}
			\end{center}
		\end{figure}
		
		\newpage
		
		Nous avons aussi défini des fonctions pour Yacc afin de lui indiquer la syntaxe à suivre pour le langage de programmation utilisé (ici le langage C).
		Pour donner un exemple, sur les expressions de multiplications, nous indiquons qu'une multiplication peut prendre plusieurs formes.
		
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.7]{images/yacc1}
				\caption{Différentes formes d'expressions de multiplication.}
			\end{center}
		\end{figure}
		
		Les formes sont soit une "cast\_expression", soit une expression multiplicative multipliée par une "cast\_expression", soit une expression multiplicative divisée par une "cast\_expression" ou soit expression multiplicative modulo une "cast\_expression".
		
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.7]{images/yacc2}
				\caption{Une "cast\_expression"}
			\end{center}
		\end{figure}
		
		Une "cast\_expression" étant définie par une expression unitaire ou bien un "type\_name" entre parenthèses suivi d'une "cast\_expression". Où un "type\_name" est une autre fonction définissant ce que c'est.
		
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.7]{images/yacc3}
				\caption{Une expression unitaire}
			\end{center}
		\end{figure}
		
		Nous décrivons ci-dessus toutes les formes possibles d'expressions unitaires. C'est donc en remontant toutes les clauses que l'on définit les règles syntaxiques d'un langage.
		
	\subsection{Pour ce semestre}
	
		Nous avons beaucoup travaillé pour rajouter de nombreuses fonctionnalités à notre éditeur afin qu'il soit complet et qu'il ressemble à des éditeurs déjà existant.\\
		
		Voici donc la liste de ce qui a été ajouté depuis les vacances de Noël :
		
		\begin{itemize}
			\item Différents thèmes et styles pour l'éditeur et ses éléments
			\item Traitement des projets
			\item Fichiers de configuration au format XML
			\item Intégration d'un compilateur
			\item Fonctionnalités diverses de recherche et d'édition de texte
			\item Inspecteur d'éléments
			\item Une autre barre de statut pour d'autres types d'informations
			\item Les numéros de lignes
			\item Fenêtre de paramétrage des raccourcis
			\item Ajout de cache afin d'optimiser l'ouverture de fichiers
			\item Grammaire arithmétique puis grammaire python
			\item Ajout de l'Anglais
			\item Quelques bonus \\
		\end{itemize}
		
		\textit{À noter que nous avions réalisé des rapports au fur et à mesure de l'avancement. Nous les reprenons ici donc en les ré-adaptant à l'aspect global évidemment. Mais il peut rester des images notamment sur la barre de menu où les fonctionnalités ne sont plus placées au même endroit. Par exemple, le menu apparence est maintenant placé dans Fichier/Paramètres.}
		
	\subsection{Librairies utilisées}

Pour mener ce projet, nous avons eu besoin de librairies extérieures. Nous utilisons Qt (version 4.8.7) qui est une interface de programmation orientée objet développée en C++ qui supporte les bindings avec notre langage de programmation, Python (version 3.4) grâce à la librairie PySide (version 1.2.1).
Nous utilisons le XML (confère partie 7) et le JSON. Le JSON (JavaScript Object Notation) est un format de données textuelles. Il ne comprend que deux types d'éléments structurels : des ensembles de paires noms/valeurs et des listes ordonnées de valeurs. Nous l'avons utilisé plutôt que le XML pour stocker certaines données, par simplicité.
Pour pouvoir colorer et analyser nos fichiers, nous utilisons PlyPlus, basée sur la librairie Ply "Python Lex et Yacc" (confère partie 13).

\section{Les schémas UML de l'IDE}

L'UML (langage de modélisation unifié) est un langage qui nous a permis, au travers de ce projet, d'en visualiser la conception. Nous avons pu, grâce à cette modélisation, voir quels étaient les modules principaux de notre IDE, de voir ce que nous allions utiliser, comment nous allions le faire...

	\subsection{Premier semestre}
	
	Au premier semestre, nos schémas présentaient quels objets de Qt étaient utilisés et les relations entre les modules que nous avions. Les voici :
	
	\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.35]{images/imgs_uml/uml_module_gui_heritage.jpg}
				\caption{L'héritage des objets de Qt}
			\end{center}
	\end{figure}

\newpage
	
	\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.4]{images/imgs_uml/relations_modules.jpg}
				\caption{Les relations entre nos vieux modules}
			\end{center}
	\end{figure}
	
	Nous avons ré-utilisé ces modules. Ils sont dorénavant plus complets, et en utilisent de nouveaux.
	
	\subsection{Deuxième semestre}

Nous avons donc continué à générer des schémas UML pour que chacun comprenne le fonctionnement de chaque nouveau module et son utilité. Nous avons une partie IHM et une partie qui travaille en arrière-plan (comme l'analyse et la compilation) :

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.43]{images/imgs_uml/dependances_graphique.png}
				\caption{Les dépendances entre tous les modules}
		\end{center}
	\end{figure}
	
	\newpage
	
	Aussi, nos modules IHM utilisent quasiment tous des modules d'arrière-plan, et même s'utilisent entre eux. Il nous a fallu faire attention aux dépendances circulaires, ce à quoi le schéma suivant nous a aidé.
		
	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.425]{images/imgs_uml/dependances_modules_gui.png}
				\caption{Les dépendances entre nos modules concernant l'IHM et l'arrière-plan}
		\end{center}
	\end{figure}
	
	\newpage
	
		Cela nous a aussi permis de comprendre quel module avait besoin de quel autre, et ainsi de ré-arranger nos importations des différents modules, qui devenaient de plus en plus longues au fur et à mesure que nous en ajoutions. Nous avons pu voir quels objets de Qt nous utilisions ce qui nous a aidé à corriger l'utilisation de certains et d'en utiliser d'autres plus appropriés.
		
Nous avons un nombre élevé de modules pour des raisons de lisibilité. Il faut préciser ici que l'on considère chaque fichier comme un module. En effet, si, par exemple, nous avions laissé le code de notre IHM dans notre module graphique, nous nous serions retrouvés avec beaucoup trop de lignes dans un seul fichier. Ce nombre élevé de modules permet donc de trouver et de régler plus facilement les erreurs.

Pour cette partie IHM, nous avons comme objet un éditeur de texte, un navigateur de fichiers, un inspecteur de fichiers, un onglet, un menu, une barre de statut, un bouton (qui eux, sont rassemblés dans la fenêtre principale) et une fenêtre pop-up. Ainsi, nous avons une classe de QT correspondant à chaque objet, comme vous pouvez le voir sur le schéma suivant :
		
	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.46]{images/imgs_uml/new_relation_Qt.png}
				\caption{Les objets utilisés en fonction des différents modules de l'IHM}
		\end{center}
	\end{figure}
		
\newpage

\section{Interface Homme-Machine (IHM)}
		
	\subsection{Les thèmes et les styles}
	
	Afin de pouvoir rendre l'application plus agréable à utiliser pour chaque utilisateur, nous avons choisi de permettre la personnalisation du thème global.
	Voici quelques exemples de thèmes : 
	
	
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.2]{images/imgs_themes/theme_forest}
				\caption{Thème Forêt}
			\end{center}
		\end{figure}
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.2]{images/imgs_themes/theme_basic}
				\caption{Thème de base}
			\end{center}
		\end{figure}
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.2]{images/imgs_themes/theme_pastel}
				\caption{Thème Pastel}
			\end{center}
		\end{figure}
		
		\newpage
			\subsubsection{Changer de thème}
		
			Le changement de thème est très simple. Il suffit de se rendre dans le menu "Fichier/Paramètres" puis de choisir son thème parmi ceux proposés dans les catégories clairs et sombres.
	
			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.5]{images/imgs_themes/choix_theme}
					\caption{Choix de son thème}
				\end{center}
			\end{figure}
			
			Lorsqu'on sélectionne son thème il est immédiatement changé, il n'y a pas besoin de relancer l'application. De plus, une petite icône apparaît à côté du thème que vous avez choisi dans la barre de menu.\\
			
			Le thème sélectionné est alors écrit dans le fichier conf.xml qui est situé à la racine du projet. Ainsi, lorsque vous relancerez l'IDE, le dernier thème que vous avez utilisé sera rechargé.
			
			\subsubsection{Gestion des thèmes}
		
			Les thèmes sont regroupés dans des répertoires distincts, le tout dans le répertoire "theme" situé à la racine du projet. 
			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/imgs_themes/themes}
					\caption{Contenu du répertoire "theme"}
				\end{center}
			\end{figure}
			
			Chaque répertoire de thème regroupe les fichiers en format .json qui contiennent les couleurs en RGB de chaque élément de l'interface graphique.
			
			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/imgs_themes/basic_json}
					\caption{Contenu du répertoire "basic" (le contenu est semblable pour tous les thèmes)}
				\end{center}
			\end{figure}
			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/imgs_themes/exemple_json}
					\caption{Exemple de fichier .json pour les thèmes.}
				\end{center}
			\end{figure}
			
			Le module theme.py nous permet de récupérer le thème sauvegardé (dans le fichier conf.xml) lors du chargement de l'application notamment. Ici sont également contenues les méthodes permettant à l'interface d'aller chercher les couleurs qu'elle doit appliquer aux différents éléments.\\
			
			Au niveau technique, nous utilisons la méthode .setStyleSheet() de QT qui peut s'appliquer à la majorité des widgets (tous dans notre cas) et qui nous permet donc de spécifier et de modifier les couleurs de fond ainsi que de police des widgets en fonction du thème choisi.
			
			\subsubsection{Création de thèmes}
		
			Vous pouvez utiliser les thèmes pré-définis, qui ont été pour la plupart validés et certifiés par la totalité du groupe comme étant jolis, mais vous pouvez aussi créer vos propres thèmes.\\
			
			Le script "createtheme.py" vous permet cela, et la démarche à suivre est expliquée dans le fichier README.txt.\\
			
			Pour résumer, on lance le fichier createtheme.py via un terminal en spécifiant le nom du thème. Tapez par exemple :
			"python3 createtheme.py monNouveauTheme" et cela créera un répertoire "monNouveauTheme" qui contiendra les fichiers nécessaires à la gestion de votre thème. Ouvrez ensuite les fichiers .json et définissez vos propres couleurs (par défaut tout est noir).\\
			
			Une fois cela fait, vous devrez ajouter deux lignes dans le module menu.py pour que votre thème apparaisse dans la sélection.

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.5]{images/imgs_themes/add2}
					\caption{Ici nomTheme est le nom de la variable pour le thème, et monNouveauTheme le nom que vous avez donné à votre thème}
				\end{center}
			\end{figure}
			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/imgs_themes/add1}
					\caption{Ici nomTheme est le nom de la variable pour le thème, et groupetheme le groupe (clair ou sombre) auquel appartient votre thème}
				\end{center}
			\end{figure}
			
			Votre thème apparaît maintenant dans la barre de menu et il est sélectionnable !
					
			\subsubsection{Style externe}
	
		Dans le répertoire "gui" qui contient tout ce qui est relatif à l'interface graphique, il y a un répertoire "style" qui regroupe des éléments auxquels on applique également des feuilles de styles (via la méthode setStyleSheet() des widgets dans QT; de même que pour les thèmes).
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_themes/style}
				\caption{Contenu du répertoire style}
			\end{center}
		\end{figure}
		% \newpage
				
		Chaque document .css contient le style relatif à des éléments. Nous retrouvons ici le style appliqué :
		
		\begin{itemize}
			\item aux boites de dialogue
				\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=0.4]{images/imgs_themes/quit}
						\caption{ Exemple de la fermeture de l'IDE : une popup qui apparaît demandant la confirmation.}
					\end{center}
				\end{figure}
				
			\item aux boutons, à qui on inverse les couleurs lorsqu'on les survole
				\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=1]{images/imgs_themes/bout1}
						\caption{Style appliqué à un bouton normal.}
					\end{center}
				\end{figure}
				\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=1]{images/imgs_themes/bout2}
						\caption{Le même bouton lorsqu'il est survolé par la souris.}
					\end{center}
				\end{figure}
				
			\item à la barre de progression
			\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=0.7]{images/imgs_themes/progress2}
						\caption{La barre de statut (voir ci-dessous).}
					\end{center}
				\end{figure}
		\end{itemize}
		
	\subsection{Informations sur le code}

		\subsubsection{Une autre barre de statut}
	
		Nous avons également travaillé à étoffer l'interface. Nous avons rajouté une seconde barre de statut (en bas à droite), servant à afficher des informations sur le code lui-même :
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=1]{images/imgs_themes/nb_lignes}
				\caption{Le nombre de lignes du fichier courant}
			\end{center}
		\end{figure}
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=1]{images/imgs_themes/nb_occu}
				\caption{Le nombre d'occurences d'une recherche effectuée}
			\end{center}
		\end{figure}
		
		Nous utilisons de plus cet emplacement (en bas à droite) pour afficher une barre de statut qui sert à indiquer la progression lors du chargement de projet (Yacc lisant tous les fichiers afin de récupérer les différentes fonctions à travers les modules, cela peut prendre plusieurs secondes).
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=1]{images/imgs_themes/progress}
				\caption{Barre de progression lors du chargement d'un projet de l'utilisateur}
			\end{center}
		\end{figure}
		
		L'ouverture de projets est maintenant beaucoup plus rapide qu'au début du semestre, notamment grâce à l'utilisation du cache. La barre de progression apparaît toujours, mais c'est souvent très rapide.
		
	\subsection{Numérotation des lignes}
	
		\subsubsection{Insertion dans l'interface graphique}

	L'objet que nous utilisons pour afficher et éditer le code est un QTextEdit de QT. Il ne possède pas de méthode pour afficher les numéros de lignes, et il n'y a pas d'autres alternatives à celui-ci pour faire cela non plus.
	
	Il nous fallait donc un autre élément, afin d'afficher les numéros de lignes qui serait placé sur le côté, nous avons choisi le côté gauche.
	
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.2]{images/imgs_lines/avant}
				\caption{Sans la barre de numérotation des lignes}
			\end{center}
		\end{figure}
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.3]{images/imgs_lines/apres}
				\caption{Avec la barre de numérotation des lignes}
			\end{center}
		\end{figure}
		
		\newpage
		
	L'utilisateur peut choisir d'afficher ou non cette barre.
	
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.8]{images/imgs_lines/menu}
				\caption{Dans le menu apparence}
			\end{center}
		\end{figure}
		
		\subsubsection{Surcharger les méthodes originales}

	La difficulté n'était pas d'afficher une barre avec des numéros dedans, ni de récupérer le nombre de lignes, car nous avons une méthode pour cela. La difficulté était de synchroniser le défilement des deux éléments (widgets).\\
		
		Lorsque l'on fait un défilement avec la molette de souris ou le pad \textbf{uniquement}, la méthode appelée sur le QTextEdit est le "wheelEvent(e)" où "e" est l'événement utilisé par QT pour effectuer le défilement.\\
		
		Le principe consiste à appeler la fonction d'origine ainsi que celle de l'autre objet avec le même argument "e" lorsque la méthode "wheelEvent()" est appelée.
		
		%\newpage
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.9]{images/imgs_lines/wheel_lines}
				\caption{Méthode de l'objet contenant la numérotation des lignes}
			\end{center}
		\end{figure}
		
		
		Ici, "self.master.codes" désigne la liste des onglets de codes ouverts, et "self.master.get\_idx()" retourne l'indice de l'onglet courant. On appelle donc la méthode "wheelEvent()" de l'onglet courant lorsque l'on fait défiler la liste de numérotation des lignes. L'argument booléen sert à dire qu'il ne faut pas rappeler la méthode "wheelEvent()" car sinon on rentrerait dans une boucle infinie.\\
		
		\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.7]{images/imgs_lines/wheel_code}
				\caption{Méthode de l'objet contenant le code}
			\end{center}
		\end{figure}
		
		"self.parent.nb\_lignes" désigne l'objet contenant la numérotation des lignes, on y appelle donc la méthode "wheelEvent()" avec les même arguments. Et toujours l'argument empêchant la boucle infinie.\\
		
		Nous arrivons ainsi à synchroniser les deux éléments lors du défilement de l'un comme de l'autre avec la souris ou le pad.
		
\section{Edition}
		
	\subsection*{Recherche et édition du texte}

	\subsection{Sélection de la ligne courante}

	Dans un premier temps, nous avons ajouté une fonction permettant de sélectionner la ligne où se trouve le curseur.
	Pour cela, nous récupérons l'objet QTextCursor de notre classe Editeur (héritant de QTextEdit) puis nous utilisons la méthode \textbf{select} de cet objet qui nous permet de sélectionner du texte dans notre Editeur, cette méthode prend en paramètre une méthode de selection, QTextCursor.LineUnderCursor dans notre cas. La ligne où se trouve notre curseur va donc être éelectionnée.
	Pour appliquer ces modifications, nous devons appliquer notre objet QTextCursor à notre Editeur, pour cela on utilise la méthode \textbf{setTextCursor} de l'objet Editeur et on lui passe en paramètre notre QTextCursor.  


	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/utilisation_selection_ligne}
			\caption{Action du menu permettant la sélection de la ligne courante}
		\end{center}
	\end{figure}

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_selection_ligne}
			\caption{Résultat de l'utilisation de la fonction sélection de la ligne courante}
		\end{center}
	\end{figure}

	\subsection{Sélection du mot courant}

	Pour l'ajout de la sélection du mot courant, la démarche est exactement la même que pour la sélection de la ligne courante, nous devons simplement changer la méthode de sélection, passant de QTextCursor.LineUnderCursor à QTextCursor.WordUnderCursor, afin de ne plus sélectionner la ligne mais le mot présent au niveau du curseur. 

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.4]{images/imgs_edit/utilisation_selection_mot}
			\caption{Action du menu permettant la sélection du mot courant}
		\end{center}
	\end{figure}

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_selection_mot}
			\caption{Résultat de l'utilisation de la fonction sélection du mot courant}
		\end{center}
	\end{figure}
	
	%\newpage

	\subsection{Duplication}

	Pour l'ajout de la duplication du texte, nous avons choisi de différencier deux cas, le premier où rien n'est sélectionné et le second où du texte est déjà sélectionné. Dans le premier cas, toute la ligne est dupliquée et dans le second seule la partie sélectionnée est dupliquée.

	Pour cela, nous récupérons une nouvelle fois le QTextCursor de notre Editeur, puis pour savoir dans quel cas nous sommes on utilise la méthode selectedText de l'objet QTextCursor. Ainsi, si aucun text n'est sélectionné nous sélectionnons la ligne courante comme précédemment. De plus, on assigne la valeur  \textbf{\\n} à la variable \textbf{return\_}. En effet si on duplique une ligne entière, on retourne à la ligne entre la sélection d'origine et la partie dupliquée. Puis on ajoute le texte dans notre objet Editeur grâce à la méthode \textbf{inserText} avec en paramètre la sélection du QTextCursor (récupérée grâce à la méthode \textbf{selectedText}) suivie de la variable \textbf{return\_} elle même suivie de la sélection du QTextCursor.

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/utilisation_duplication}
			\caption{Action du menu permettant de dupliquer}
		\end{center}
	\end{figure}


	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_duplication}
			\caption{Résultat de l'utilisation de la fonction permettant de dupliquer}
		\end{center}
	\end{figure}

	\newpage
	\subsection{Recherche}

	Pour la recherche dans le document, nous avons décidé d'ajouter une boîte de dialogue permettant d'entrer le texte à rechercher. Pour cela nous avons créé une classe SearchDialog (héritant de QDialog). Lors de l'affichage de cette boîte de dialogue nous utilisons la méthode \textbf{exec}, qui rend impossible l'interaction avec la fenêtre en arrière-plan tant que la boite de dialogue est ouverte.

	Cette boite de dialogue nous permet de taper le texte à rechercher, de choisir si on recherche en avant ou en arrière, mais aussi si on veut être sensible à la case.

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/boite_dialog_recherche}
			\caption{Boîte de dialogue relative à la recherche}
		\end{center}
	\end{figure}

	Pour la recherche, nous utilisons la méthode \textbf{find} de notre objet Editeur. Cette méthode prend en paramètre le texte à rechercher, suivi de différents drapeaux. Dans notre cas, nous utilisons le drapeau permettant d'exécuter la rechercher en arrière et le drapeau permettant de faire la recherche en étant sensible à la case (respectivement les drapeaux \textbf{QTextDocument.FindBackward} et \textbf{QTextDocument.FindCaseSensitively})

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/utilisation_rechercher}
			\caption{Action du menu permettant de rechercher}
		\end{center}
	\end{figure}

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_rechercher}
			\caption{Résultat de l'utilisation de la fonction permettant de rechercher}
		\end{center}
	\end{figure}
	\newpage

	\subsection{Indentation du fichier}

	Pour l'indentation du document, nous allons changer son contenu (ajout/retrait de tabulation). Nous devons donc stocker la position courante du curseur (grâce à la méthode \textbf{blockNumber} de l'objet QTextCursor). Par la suite, on récupère le contenu du document grâce à la méthode \textbf{toPlainText} de l'objet Editeur. On créé une variable \textbf{indent\_level}, qui contient le niveau courant d'indentation, puis on parcourt toutes les lignes de notre document. Si la ligne contient le caractère "\}", on retire 1 au niveau d'indentation puis on change la ligne pour ajouter au début de cette dernière \textbf{indent\_level} fois une tabulation, puis on ajoute 1 au niveau d'indentation si la ligne contient "\{".
	Pour finir on définit le nouveau texte ainsi obtenu comme texte de notre document avec la méthode \textbf{setPlainText} et on replace le curseur au bon endroit.

	\begin{figure}[h!]

		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/utilisation_indentation}
			\caption{Action du menu permettant d'indenter le fichier}
		\end{center}
	\end{figure}

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_indentation}
			\caption{Résultat de l'utilisation de la fonction permettant d'indenter le fichier}
		\end{center}
	\end{figure}

	\subsection{Commenter la sélection}

	De la même façon que pour la duplication du texte, nous avons séparé cette action en deux cas, soit du texte est sélectionné soit rien n'est sélectionné.
	Dans le cas où du texte est sélectionné nous commenterons seulement à partir du début de la sélection. Si plusieurs lignes sont sélectionnées elles seront évidemment toutes commentées. Si il n'y a pas de texte sélectionné, on commente la ligne courante.

	Dans un premier temps, comme pour la duplication, si rien n'est sélectionné on sélectionne la ligne courante, puis on sauvegarde le texte sélectionné que l'on récupère grâce à la méthode \textbf{selectedText}, puis on supprime le texte sélectionné avec la méthode \textbf{removeSelectedText}. Pour savoir si le texte est déjà commenté, nous parcourons toutes les lignes, si une des lignes ne commence pas par "//" la sélection est considérée comme non commentée. Par la suite nous parcourons chaque ligne du texte puis pour chaque ligne nous ajoutons/retirons les caractères "//" en fonction de si le texte est déjà commenté ou non.

	Puis on ajoute le texte ainsi modifié à notre document en utilisant la méthode \textbf{insertText} (de l'objet QTextCursor).

	\begin{figure}[h!]

		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/utilisation_commentaire}
			\caption{Action du menu permettant de commenter le fichier}
		\end{center}
	\end{figure}

	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.8]{images/imgs_edit/resultat_commentaire}
			\caption{Résultat de l'utilisation de la fonction permettant de commenter le fichier}
		\end{center}
	\end{figure}
	
\subsection{Les snippets}
	
	\subsubsection{Les snippets : explication}

		Les snippets sont des bouts de code qui sont réutilisables d'un projet à un autre (comme les conditions, les boucles et les définitions de fonction par exemple). Dans notre IDE nous utilisons des mots clés que l'on associe à ces bouts de code. Lorsque l'on tape un des mots clés puis que l'on presse la touche \textbf{tabulation}, le mot clé est remplacé par le bout de code qui correspond.

	\subsubsection{Intégration des bouts de code dans l'IDE}

		\paragraph{Utilisation du JSON}

			Pour l'intégration des snippets dans l'IDE, nous avons utilisé des fichiers JSON, qui contiennent des dictionnaires avec comme clé le mot clé qui correspond au bout de code et comme valeur le-dit bout de code, suivi de nombre de lignes que le curseur doit remonter, puis le nombre de caractères "char" que le curseur doit parcourir vers la droite pour être à l'emplacement voulu. Nous avons un fichier JSON par langage (C, python, etc ... ).

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/exempleJSON}
					\caption{Extrait du fichier JSON pour le language C}
				\end{center}
			\end{figure}

		\paragraph{Connexion entre le JSON et l'IDE}

			Pour capturer l'appui sur la touche \textbf{tabulation}, nous utilisons la méthode \textbf{keyPressEvent} de notre classe \textbf{Editeur}. Cette méthode est appelée à l'appui sur une des touches du clavier. Par la suite, si la touche est la touche \textbf{tabulation}, nous parsons le JSON pour avoir touts les couples (mot clé, bout de code). Puis en fonction du mot placé au niveau du curseur, on le remplace ou non par le bout de code correspondant.

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/exampleFor}
					\caption{Exemple d'utilisation des snippets avec une boucle for en Python}
				\end{center}
			\end{figure}

\section{Fichier de configuration XML}

L'Extensible Markup Language (XML, « langage de balisage extensible » en français) est un métalangage informatique de balisage générique qui dérive du SGML. Cette syntaxe est dite « extensible » car elle permet de définir différents espaces de noms, c'est-à-dire des langages avec chacun leur vocabulaire et leur grammaire, comme XHTML, XSLT, RSS, SVG… Elle est reconnaissable par son usage des chevrons (<, >) encadrant les balises. 
%\newpage
La boîte à outils XML lxml est une liaison Pythonic pour les bibliothèques C libxml2 et libxslt. Il combine la vitesse et la simplicité d'une API native Python, la plupart du temps compatible mais supérieure à l'API ElementTree. La dernière version fonctionne avec toutes les versions de CPython de 2.6 à 3.6. Nous avons utilisé la librairie LXML (version 3.7.2) qui fait le lien entre Python et le XML, qui nous permet d'utiliser des outils de parse XML dans notre IDE avec Python. 

\subsection{Pourquoi le XML}

Au fur et à mesure de l'ajout de fonctionnalités dans notre IDE, l'utilisation du XML s'est vite imposée du fait de son efficacité. En effet, l'outil "etree", après son import, nous permet de parser un fichier XML, de le parcourir et de le modifier en fonction de nos besoins dans l'élaboration des différentes fonctionnalités de notre IDE. Nous utilisons plusieurs fichiers xml, un pour chaque projet, un pour tous les projets et un fichier de configuration. 

\subsection{Le module XML et le fichier de configuration}

Nous avons donc ainsi créé un module XML pour les fonctions de parcours et d'écriture de fichier XML et pour le fichier de configuration XML. Voici d'ailleurs leur disposition dans notre IDE, ils sont à la racine du projet.

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.23]{images/imgs_xml/dossier.png}
				\caption{Disposition du module et du fichier de configuration}
			\end{center}
		\end{figure}
		
Dans le module XML, nous avons une fonction open\_xml, qui ouvre, parse et parcourt le fichier de configuration XML pour retourner un dictionnaire avec comme clés le nom des balises XML, et comme valeurs la valeur des balises. Nous avons également une fonction write\_xml qui permet d'écrire des modifications dans le fichier de configuration. On rentre le nom d'une balise et la valeur voulue en arguments, la fonction trouve la balise et lui associe cette valeur, puis nous écrivons dans le fichier. Enfin, pour éviter tout problème, si le fichier de configuration n'existe pas ainsi que le fichier comportant tous les projets, on les crée et leur ajoute les valeurs de configuration de base. \\
		
Dans le fichier de configuration ".xml", nous utilisons une balise pour stocker : le thème sélectionné actuel, le booléen suivant l'activation ou non de l'assistance vocale dans l'interface graphique, le booléen suivant l'activation ou non de l'écran de chargement au démarrage, celui de la numérotation des lignes, le langage de l'IDE (Français ou Anglais) ainsi que la localisation du workplace (voir partie suivante).
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.6]{images/imgs_xml/conf.png}
				\caption{Fichier de configuration}
			\end{center}
		\end{figure}
		
\subsection{Les projets et le XML}

	Il y a un fichier ".xml" dans chaque projet. Ce fichier contient notamment le langage du projet, la date de création, son nom, son emplacement, le nombre de fichiers qu'il contient, l'emplacement de son compilateur et l'emplacement de son fichier de sortie.\\
	
	\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.6]{images/imgs_xml/projet_xml.png}
				\caption{Fichier de configuration}
			\end{center}
		\end{figure}
		
		On peut donc aisément rajouter et récupérer les informations qu'il contient afin de les utiliser pour diverses raisons, comme compiler le projet sans avoir à remettre toutes les options nécessaires.
	
\section{Traitement des projets}

\subsection{La mise en place du concept de projet}

Le concept de projet dans un IDE consiste à avoir un dossier Workplace qui comporte tous les dossiers de projets et il peut être placé où on veut. Après avoir réalisé ce concept, il ne restait plus qu'à faire les différentes fonctions associées aux projets, comme la création d'un nouveau projet, l'import, la suppression et les informations de chaque projet.
	
\subsection{La création d'un nouveau projet}
		
Pour créer un nouveau projet, il suffit de cliquer sur le bouton du menu "Nouveau projet", une fenêtre s'ouvre et propose de choisir un nom de projet et un langage. Après validation le dossier du projet est créé avec l'xml contenant ses informations dedans. Le dossier est considéré comme un projet et est stocké dans le fichier xml contenant tous les projets.

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.4]{images/imgs_projet/creation_project.png}
				\caption{Interface graphique de création de projet}
			\end{center}
		\end{figure}
		
		\newpage

Nous pouvons maintenant ajouter du code et donc des fichiers dans le nouveau projet créé.

\subsection{Importation de projet}

Pour importer un projet déjà créé dans le Workplace ou ailleurs, qui ne comprend donc pas de fichier xml, qui n'est donc pas encore considéré comme un projet par l'IDE, il suffit de cliquer sur le bouton du menu "Importer projet". Il l'ajoute au Workplace avec un fichier xml et fait toutes les formalités comme lors de la création d'un projet. Tous les cas sont gérés, à savoir par exemple, l'ajout d'un projet déjà existant dans le Workplace : rien ne se passe et le projet n'est pas écrasé. Il est également possible d'importer un ancien projet qui est dans le Workplace avec le menu clic droit du navigateur de projets et en cliquant sur "Importer le projet".

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.4]{images/imgs_projet/import.png}
				\caption{Interface graphique d'import de projet}
			\end{center}
		\end{figure}
		
\subsection{Suppression de projet}

Pour supprimer un projet, il suffit de cliquer sur le bouton du menu "Supprimer projet". Ainsi, le dossier projet est supprimé du Workplace, nous avons utilisé la commande "shutil.rmtree". Avec la même méthode, nous pouvons supprimer un fichier et même un dossier dans un projet, via par contre le menu clic droit du navigateur de projets, dont nous allons parler dans une prochaine partie.

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/supp_project.png}
				\caption{Interface graphique de suppression de projet}
			\end{center}
		\end{figure}

\subsection{Informations de projet}

Pour accéder aux informations d'un projet, il suffit de cliquer sur le bouton du menu "Informations projet". Ainsi, une fenêtre s'ouvre et propose de choisir un projet. Une fois le projet choisi, ses informations sont affichées, soit le nom, le langage, la localisation, la date de création et le nombre de fichiers du projet. On peut également modifier les informations, enfin seulement le nom et le langage du projet. Pour finir, il faut simplement appliquer les modifications effectuées avec le bouton correspondant. Vous pouvez le voir avec les images ci-dessous :

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/info_project1.png}
				\caption{Interface graphique de sélection d'informations de projet}
			\end{center}
		\end{figure}
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/info_project2.png}
				\caption{Interface graphique des informations de projet}
			\end{center}
		\end{figure}
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/info_project3.png}
				\caption{Interface graphique de modification des informations de projet}
			\end{center}
		\end{figure}

\subsection{Menu clic droit du navigateur de projets}

Un menu s'affichant par un clic droit dans le navigateur de projets a été mis en place. Il permet d'importer un projet, de le supprimer et d'afficher ses informations. Il est également possible de renommer et de supprimer les dossiers et fichiers présents un projet. Ce sont donc les mêmes fonctionnalités que précédemment (avec en plus la suppression et la possibilité de renommer les dossiers et fichiers de projets) mais présentées de façon plus pratique, efficace, optimale pour travailler. Vous pouvez le voir avec les images ci-dessous :


\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/right_click_import.png}
				\caption{Import projet via le menu clic droit}
			\end{center}
		\end{figure}
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/right_click_project.png}
				\caption{Suppression et informations de projet via le menu clic droit}
			\end{center}
		\end{figure}
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/right-click-dir.png}
				\caption{Suppression et possibilité de renommer un dossier}
			\end{center}
		\end{figure}
		
\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/right_click_file.png}
				\caption{Suppression et possibilité de renommer un fichier}
			\end{center}
		\end{figure}

		\newpage
		
Lorsque que l'on clique sur le bouton pour renommer, nous obtenons l'affichage d'une fenêtre proposant d'écrire un nouveau nom :

%\newpage

\begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/rename.png}
				\caption{Renommer un dossier ou un fichier de projet}
			\end{center}
		\end{figure}
		
		
Lorsque l'on clique sur le bouton pour afficher les informations de projet, nous obtenons un affichage différent de cette même fonctionnalité présentée dans la partie précédente étant donné qu'il faut présenter les informations d'un seul projet. Il est impossible de modifier les informations de part ce menu clic droit et de renommer le nom de projet, il faut pour cela faire comme expliqué dans la partie précédente via le menu principal. Nous pouvons le voir avec l'image ci-dessous :

 \begin{figure}[h!]
			\begin{center}
				\includegraphics[scale=0.5]{images/imgs_projet/info_project4.png}
				\caption{Rendu des informations de projet via le menu clic droit}
			\end{center}
		\end{figure}


\section{Compilateur}

	\subsection{Compilateurs utilisés}

		Pour notre IDE, nous avons utilisé le compilateur \textbf{GCC}, pour compiler les projets de type \textbf{C}. Mais nous utilisons aussi les interpréteur de python afin d'interpréter les projets de type \textbf{Python}. Par la suite, pour chaque nouveaux langages il nous suffit d'utiliser le bon compilateur ou le bon interpréteur.
		
	\subsection{Intégration de \textbf{GCC} à notre IDE}

		Pour utiliser \textbf{GCC} avec notre IDE, nous avons créé une fenêtre de configuration afin de permettre à l'utilisateur de choisir la configuration adéquate à la compilation de son projet.

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.7]{images/fenCompEx}
					\caption{Fenêtre de configuration de GCC}
				\end{center}
			\end{figure}

		Chaque information de cette fenêtre est convertie en une chaîne de caractère du type : 

		gcc /Users/theosarrazin/workplaceC/ProjetDeTest/test.c  -I /Users/theosarrazin/workplaceC/

		ProjetDeTest/header -o MonExecutable

		Cette chaîne de caractère est stockée dans le fichier XML de configuration du projet.

		Pour finir, on exécute cette ligne de commande, puis on récupère sur la sortie d'erreur les éventuelles erreurs afin de pouvoir les afficher à l'utilisateur après les avoir parsées pour avoir un bon formatage.

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.6]{images/fenErreurEx}
					\caption{Affichage des erreurs de GCC dans l'IDE}
				\end{center}
			\end{figure}

		En ce qui concerne la partie interpréteur pour le langage Python, la démarche est semblable. 


\section{Inspecteur d'éléments}

	Lorsqu'un document est ouvert, nous avons la possibilité d'afficher l'inspecteur d'éléments. Pour cela, nous avons le bouton "Navigateur" sous le navigateur de fichiers, et lorsque l'on clique dessus, on affiche l'inspecteur à la place. De même si on re-clique dessus, on ré-affiche le navigateur.
	
	\begin{figure}[h!]
		\begin{center}
			\includegraphics[scale=0.5]{images/insp_nav.png}
			\caption{Respectivement l'inspecteur et le navigateur de fichiers sont affichés}
		\end{center}
	\end{figure}
	
	\newpage
	
	Au niveau du code, le navigateur de fichiers est créé à l'aide d'un QTreeView (comme au premier semestre), et il est remplacé par un QTextEdit qui constitue l'inspecteur lorsqu'on clique sur le bouton.\\
	
	On affiche dans l'inspecteur toute la structure du code grâce au logiciel Yacc, qui peut nous renvoyer des listes contenant pour un fichier :
	
	\begin{itemize}
		\item Ses variables
		\item Ses fonctions
		\item Ses struct (en C) ou ses Class (en Python)\\
	\end{itemize}
	
	Lorsque l'on clique sur un élément par exemple un nom de variable, cette variable est sélectionné dans le document courant.

\section{Personnalisation des raccourcis}

	Dans le menu de notre IDE, vous avez pu remarquer qu'à côté de certaines options, il y avait des raccourcis que nous avions choisis en fonction de ce qui nous semblait être le mieux. Mais ces choix étaient personnels, et tous les membres du groupe n'approuvant pas certains choix, nous avons décidé de les rendre personnalisables.

	\subsection{Partie interface}

	Nous avons trois menus dans lesquels il y a des raccourcis. Ainsi, nous avons décidé de créer un fichier "racc\_defaut.json" qui contient un dictionnaire ayant pour clefs le noms de ces trois menus, et comme valeurs d'autres dictionnaires qui ont pour clefs les noms des fonctionnalités et comme valeurs une chaîne de caractères représentant le raccourci.

\begin{center}
	\includegraphics[scale=0.5]{images/imgs_racc/ex_1.png}\\
	Ici, un aperçu du fichier "racc\_defaut.json".
\end{center}

	Nous pouvons donc conserver tous les raccourcis de base et en proposer dès le lancement de l'IDE, au lieu de forcer l'utilisateur à en définir. Il peut donc choisir, via le menu "Fichier", dans le sous-menu "Paramètres", l'option Raccourcis, qui modifiera le fichier "racc\_utilisateur.json" créé lors du lancement de l'IDE si celui-ci n'existait pas déjà.\\

	Cliquer sur cette option lui ouvrira une nouvelle fenêtre (une QDialog), dans laquelle trois onglets (des QTabWidget) seront disponibles. Ces trois onglets correspondent aux trois menus qui contiennent des raccourcis. Dans ces onglets, des lignes de saisies (des QLineEdit) seront apparentes permettront à l'utilisateur de rentrer ses propres raccourcis. Nous avons mis les raccourcis de base en fond pour que l'utilisateur ait un modèle. Cette interface est complétée par deux boutons, l'un qui valide les raccourcis et l'autre qui les remet à zéro, c'est-à-dire qu'il modifie les valeurs contenues dans le fichier "racc\_utilisateur.json",  et les remplace par les valeurs contenues dans le fichier "racc\_defaut.json".

\begin{center}
	\includegraphics[scale=0.4]{images/imgs_racc/ex_2.png}\\
	Un aperçu de la fenêtre permettant la modification des raccourcis.
\end{center}

	\subsection{Partie modification}

En ce qui concerne la modification des raccourcis, il est possible de d'écrire tout ce que l'on veut dans les lignes de saisies.
Il n'est néanmoins pas nécessaire de d'écrire à la main "Ctrl" "+" "...". Les touches telles que "Ctrl", "Shift", "Alt" verront leurs noms écrit après simple pression sur leur touche (utilisation de la fonction "keyPressEvent").
C'est lorsque l'on clique sur le bouton valider que la fonction qui valide un raccourci va être appelée. Ainsi, certaines combinaisons de touches ne sont pas permises, telles que "M+Shift+Ctrl". Nous avons aussi décidé de faire en sorte que si l'utilisateur écrit quelque chose de ce style : "Ctrl+Shift+JHGFFUTRF", on écrive dans le fichier "racc\_utilisateur.json" : "Ctrl+Shift+J".

\section{Optimisation}

	\subsection{Cache des documents}

		\subsubsection{Utilité du cache}

		Afin de pouvoir faire de la coloration du code, nous avons utilisé \textbf{Lex} mais pour les fichiers de plusieurs centaines de lignes \textbf{Lex} prend plusieurs secondes pour nous donner la listes des tokens du fichier. Nous avons donc décidé d'utiliser un fichier de cache afin de ne pas utiliser \textbf{Lex} pour colorer des lignes que nous avons déjà coloré auparavant.

		\subsubsection{Intégration du cache dans l'IDE}

		Pour le cache, nous avons décidé d'utiliser un fichier JSON pour l'enregistrer. Le fonctionnement est assez simple la clé est le bout de code (snippet) que l'on donne à \textbf{Lex} et la valeur est la réponse de ce dernier. Par la suite, il ne nous reste plus qu'à utiliser les valeurs du fichier JSON à la place de \textbf{Lex}

			\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.5]{images/exempleJsonCache}
					\caption{Extrait d'un JSON contenant le cache}
				\end{center}
			\end{figure}

		Grâce au cache nous avons un gain de temps considérable sur l'ouverture des documents.
		
		Nous avons créé deux fonctions, l'une vide le cache du projet courant et l'autre vide tout le cache. 
		
	\subsection{Statistiques}
	
		\subsubsection{Cache}
		
		Avant la mise en place du cache, l'ouverture d'un fichier pouvait être relativement longue à cause du traitement effectué par Lex sur ce dernier.
		
		\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.5]{images/exempleJsonCache}
					\caption{Extrait d'un JSON contenant le cache}
				\end{center}
		\end{figure}
		
		\subsubsection{Empreinte mémoire}
		
		Afin de présenter un IDE correct, nous avons réalisé quelques tests concernant la consommation de mémoire lors de diverses actions réalisées depuis notre IDE.
		
		\begin{figure}[h!]
				\begin{center}
					\includegraphics[scale=0.5]{images/exempleJsonCache}
					\caption{Extrait d'un JSON contenant le cache}
				\end{center}
		\end{figure}

\section{Nouvelles grammaires}

	\subsection{Grammaire Arithmétique}

		\subsubsection{Lex}
			
			Comme nous avons pu le voir, les règles de Lex sont définis par des tokens, chaque token étant associé à une expression régulière. 

			\paragraph{Les tokens}

				Dans le cadre d'une grammaire arithmétique nous avons besoin de différents tokens : 
				\begin{itemize}
					\item Number : le token qui va reconnaître les nombres
					\item Plus : le token qui va reconnaître le signe +
					\item Minus : le token qui va reconnaître le signe -
					\item Times : le token qui va reconnaître le signe *
					\item Divide : le token qui va reconnaître le signe /
					\item LParen : le token qui va reconnaître la parenthèse gauche
					\item RParen : le token qui va reconnaître la parenthèse droite
				\end{itemize}

				Pour être reconnu par Lex ces tokens sont stockés dans un tuple \textbf{tokens} .

			\paragraph{Les expressions régulières}

				A chacun des tokens précédents, nous devons associer une expression régulière pour que Lex puisse reconnaître les tokens.
				Pour cela, nous devons simplement créer une variable de la forme t\_NomDuToken, qui prend comme valeur l'expression régulière à associer à ce token.

				Pour le token Number, nous utilisons l'expression suivante : \textbf{\"\\b+\"}, le \textbf{\"\\b\"} signifiant n'importe quel chiffre compris entre 0 et 9 de plus le \textbf{+} signifie répété une ou plusieurs fois. En effet, un nombre est une suite de chiffre.

				Pour les six autres tokens, nous utilisons simplement le signe qui doit correspondre au token (+ pour le token Plus, - pour le token Minus, etc...)
			
				\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=1]{images/exp_regex}
						\caption{Exemple de création d'une expression régulière}
					\end{center}
				\end{figure}


			\paragraph{Fonctions et variables supplémentaires\\}

				De plus, pour l'utilisation de Lex, nous pouvons définir une variable \textbf{t\_ignore} qui va préciser les éléments à ne pas prendre en compte. Dans notre cas la variable vaut \textbf{" \t"}, nous ignorons donc les espaces et les tabulations.

				Nous pouvons aussi définir une fonction \textbf{t\_newline(t)}, qui prend un token en paramètre et qui va être utilisée pour matcher tous les retours à la lignes grâce à l'expression régulière \textbf{\"\\n+\"}. Cette fonction va ajouter pour chaque ligne trouvée 1 à l'attribut \textbf{lineno}, qui contient le nombre de lignes.

				Pour finir, une autre fonction peut être utilisée, la fonction \textbf{t\_error(t)}, qui prend elle aussi un token en paramètre et qui va être appelée par le lexer à chaque token non reconnu par ce dernier. Cette fonction va afficher un message d'erreur puis ignorer le token grâce à l'instruction \textbf{t.lexer.skip(1)}, t étant le token courant grâce auquel on récupère le lexer. 

		\subsubsection{Yacc}

			\paragraph{Création de la grammaire}

				Pour fonctionner Yacc a besoin de différentes règles de grammaires, chaque règle définissant comment peuvent "s'assembler" les différents tokens reconnus pour Lex.

				Pour définir des règles nous devons créer des fonctions nommées de la façons suivante : \textbf{p\_NomDeLaRegle}. Cette fonction doit contenir une docstring définissant les règles à respecter.

				\begin{figure}[h!]
					\begin{center}
						\includegraphics[scale=1]{images/exp_grammaire_yacc}
						\caption{Exemple d'une règle de grammaire de Yacc}
					\end{center}
				\end{figure}

				Voici nos différentes règles : 
				\begin{itemize}
					\item expression : correspond à une somme/soustraction de deux expressions. Une expression pouvant aussi être terme.
					\item terme : correspond à une multiplication/division de deux termes. Un terme pouvant aussi être un facteur.
					\item facteur : correspond à un nombre, une expression entre parenthèse ou - un facteur.
				\end{itemize}

				De plus, chacune de ces fonctions ajoute des propositions à une variable \textbf{prop} afin de les afficher par la suite dans notre IDE.

			\paragraph{Création du parser}

				Par la suite, nous devons appliquer nos règles sur du contenu, pour cela nous avons créé une fonction \textbf{parse}, qui prend en paramètre le code à parser. Par la suite, cette fonction créée le lexer (en faisant appelle à Lex), puis crée le parser (en faisant appel à Yacc). Pour finir elle revoit les listes des propositions afin de pouvoir les ajouter à les listes des propositions de notre IDE.
	
	\subsection{Grammaire Python}

		\subsubsection{Création de la grammaire}

			Dans un premier temps, nous avions commencé à rédiger une grammaire pour Python. Cependant nous avons rencontré plusieurs problèmes, notamment le fait qu'il n'est pas possible d'avoir des tokens imbriqués les uns dans les autres rendant ainsi les expressions régulière de \textbf{Lex} bien trop complexes. De plus la gestion de l'indentation n'était pas facile. En effet \textbf{PLY} ne peut pas analyser l'indentation par ces grammaires, il nous faut donc revalider chacun des tokens identifiés par \textbf{Lex} dans un second temps. Chose qui n'est pas simple à faire avec la librairie \textbf{Ply}. Voila donc pourquoi nous avons décidé d'utiliser la librairie \textbf{PlyPlus}

		\subsubsection{Utilisation de la librairie PlyPlus}

			Pour pallier aux problèmes précédents, nous avons donc choisi d'utiliser la librairie \textbf{PlyPlus}. Cette librairie se base sur la librairie \textbf{Ply} sur laquelle nous avons travaillé jusqu'à présent, il nous a donc était simple d'ajouter \textbf{PlyPlus} à notre projet. \textbf{PlyPlus} a plusieurs avantages, dont notamment le fait d'avoir un système de grammaire totalement différent de \textbf{Ply}, nous permettant ainsi de résoudre les problèmes cités auparavant. Ce ne sont pas les seuls avantages de \textbf{PlyPlus}. En effet il nous permet aussi de sélectionner très simplement un type d'élément (le nom des fonctions ou des classes présentes par exemple) rendant ainsi possible leur coloration. De plus \textbf{PlyPlus}, vient avec une grammaire python et un post-analyseur syntaxique permettant ainsi de traiter l'indentation du fichier. \\
			
			Nous utilisons donc \textbf{PlyPlus} pour interpréter notre grammaire Python et nous gardons \textbf{Ply} pour la grammaire C, car elle suffit pour ce langage.

%\newpage

\section{Langue du système en Anglais}

	\subsection{Gestion des langues}

	Nous avons ajouté la possibilité de mettre la langue de l'IDE en Anglais en plus du Français. Il suffit d'aller dans : Fichier/Paramètres/Langue et de choisir sa langue.\\
	
	\begin{figure}[h!]
			\begin{center}
					\includegraphics[scale=0.3]{images/langues}
					\caption{Dictionnaire des textes}
			\end{center}
	\end{figure}
	
	Il y a un répertoire langue situé à la racine du projet qui contient le module language.py qui permet de gérer le changement de langue ainsi que la récupération des textes selon la langue.
	
	Pour l'aspect technique, nous utilisons un dictionnaire contenu dans un fichier ".json", qui associe à chaque élément sa traduction Française et Anglaise comme le montre l'exemple suivant.
	
	\begin{figure}[h!]
			\begin{center}
					\includegraphics[scale=1]{images/langue_json}
					\caption{Dictionnaire des textes}
			\end{center}
	\end{figure}
	
	Pour chaque message, texte à afficher ou texte du menu, nous allons chercher la clef correspondante dans ce dictionnaire afin de l'afficher. 
	
	\textit{A noter que nous utilisons un second dictionnaire réservé aux textes de la barre de menu, cela nous permettait juste de ne pas avoir un très long fichier ".json" mais de répartir en deux pour des raisons de lisibilités. Mais le fonctionnement est strictement le même.}\\
	
	Nous n'avons pas trouvé de moyen d'actualiser la barre de menu lors du changement de langue. Il faut donc redémarrer l'IDE afin d'avoir les textes de la barre de menu dans la nouvelle langue choisie. En revanche tous les autres textes, c'est à dire les messages affichés sont directement dans la nouvelle langue.
	
	\subsection{Rajouter une langue}

	Si nous souhaitons intégrer une nouvelle langue, rien de plus simple !\\
	
	Il nous suffit juste d'ajouter pour chaque texte des dictionnaires la langue et sa traduction. Par exemple si on ajoute l'espagnol, sur la figure 63, on aura une clef supplémentaire "es" à chaque sous-dictionnaire qui aura pour valeur le texte correspondant à la traduction.

\section{Ajouts bonus}

	Pendant la réalisation du projet, nous avons également rajouté 2 ajouts purement ludiques qui n'ont pas forcément d'intérêt. 
	
	\subsection{L'assistance vocale}
	
		Il existe sous Mac une commande "say" qui permet de lire dans la langue du système le texte rentré après à l'aide de la synthèse vocale de la machine. C'est ce que nous avons utilisé ici, mais cette commande n'existant que sous Mac, et n'ayant pas trouvé d'alternatives, cette fonctionnalité n'est donc pas disponible ailleurs (rassurez-vous, vous ne ratez pas grand chose !).\\
		
		L'assistance vocale ne fait que lire les messages apparaissant dans la barre de statut comme : "Le projet sélectionné a bien été ouvert." par exemple.\\
		
		Pour l'activer, il suffit d'aller dans le menu Fichier/Paramètres et de cocher la ligne Assistance vocale.
		
		\begin{figure}[h!]
			\begin{center}
					\includegraphics[scale=0.15]{images/assist_voc}
					\caption{Fonctionnalité assistance vocale}
			\end{center}
	\end{figure}
	
	L'état de l'assistance vocale (si elle est activée ou non) est stocké dans le fichier de configuration conf.xml. Ainsi, au redémarrage, vous retrouverez l'assistance vocale telle que vous l'avez laissé (A l'unanimité, nous conseillons fortement de la désactiver, c'est très vite pénible) !\\
	
	Si vous n'êtes pas sous Mac, la fonctionnalité sera grisée dans le menu et vous ne pourrez pas l'activer.
	
	\newpage
	
	\subsection{La cheminée}
	
		Les hivers étant parfois rudes, avoir chaud aux mains peut s'avérer très confortable quand on code. C'est ce qu'on s'est dit et nous avons au plus vite intégré une cheminée traditionnelle à notre IDE pour le confort de nos utilisateurs.\\
		
		La cheminée en elle-même est un GIF qui est affiché dans un objet QLabel de QT et démarré à l'aide d'un QMovie.\\
		
		\begin{figure}[h!]
			\begin{center}
					\includegraphics[scale=0.3]{images/cheminee}
					\caption{Chaleureux n'est-ce pas ?}
			\end{center}
	\end{figure}
	
	On l'active au même endroit que pour l'assistance vocale, et elle est disponible sous toutes les plate-formes !\\
	
	\begin{figure}[h!]
			\begin{center}
					\includegraphics[scale=0.2]{images/activ_cheminee}
					\caption{Fonctionnalité affichage de la cheminée}
			\end{center}
	\end{figure}
	
	Attention de ne pas vous brûler !

\section{Bilan}

Un IDE nécessite un éditeur de texte, un compilateur, un interpréteur et un débogueur. Nous avons réussi à intégrer ces quatre fonctionnalités indispensables. Le code peut-être en plus coloré et analysé. Les grammaires que nous avons ajoutées permettent la compilation des langages C et Python.

Nous avons rajouté des fonctionnalités importantes mais pas indispensables, telles que celles présentées dans la partie édition. Nous avons rendue personnalisable l'interface homme-machine pour que cette dernière soit plus agréable en fonction des préférences de l'utilisateur.

\end{document}